# Cursor Rules for tonypettigrew.dev-3.0

## Project Overview

This is a Next.js 15 TypeScript project with the following tech stack:

- Next.js 15 with App Router
- TypeScript (strict mode)
- Tailwind CSS v4
- React Query (TanStack Query)
- Radix UI components
- React Icons
- Next Themes for dark/light mode

## Code Style & Standards

### TypeScript

- Use strict TypeScript with proper type annotations
- Prefer `interface` over `type` for object shapes
- Use `Readonly<T>` for props and immutable data
- Always define return types for functions
- Use proper generic constraints where applicable

### React & Next.js

- Use functional components with hooks
- Follow Next.js 15 App Router conventions
- Use `"use client"` directive only when necessary
- Prefer server components by default
- Use proper Next.js metadata exports
- Follow the `src/app` directory structure

#### Function Declarations for Components and Pages

**Use Function Declarations for:**

- **Page Components** (`page.tsx` files)
- **Layout Components** (`layout.tsx` files)
- **Server Components** (default in App Router)
- **API Routes** (`route.ts` files)

```tsx
// ✅ Preferred for pages and layouts
export default function HomePage() {
  return <div>Home Page</div>;
}

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html>
      <body>{children}</body>
    </html>
  );
}
```

**Use Arrow Functions for:**

- **Client Components** (with `"use client"`)
- **Reusable UI Components**
- **Custom Hooks**
- **Event Handlers**

```tsx
// ✅ Preferred for client components and reusable UI
"use client";

const Button = ({ children, onClick }: ButtonProps) => {
  return <button onClick={onClick}>{children}</button>;
};

const useCustomHook = () => {
  const [state, setState] = useState();
  return { state, setState };
};
```

**Rationale:**

- Function declarations are hoisted and work better with Next.js's server-side rendering
- Arrow functions are more concise for client-side components and event handlers
- Function declarations are more readable for complex page components
- Arrow functions are better for functional programming patterns in client components

### Component Structure

- Use PascalCase for component names
- Export components as default exports
- Use barrel exports (index.ts) for clean imports
- Keep components focused and single-purpose
- Use proper prop interfaces with `Readonly<T>`

### Styling

- Use Tailwind CSS classes for styling
- Follow mobile-first responsive design
- Use CSS variables for theme customization
- Prefer utility classes over custom CSS
- Use `classnames` utility for conditional classes

### State Management

- Use React Query for server state
- Use React hooks for local state
- Prefer `useState` and `useEffect` for simple state
- Use `useCallback` and `useMemo` for performance optimization

## File Organization

### Directory Structure

```
src/
├── app/                    # Next.js App Router pages
│   ├── globals.css        # Global styles
│   ├── layout.tsx         # Root layout
│   ├── page.tsx           # Home page
│   └── RootAppShell/      # App shell components
├── components/            # Reusable components
├── lib/                   # Utility functions
├── hooks/                 # Custom React hooks
└── types/                 # TypeScript type definitions
```

### Import Conventions

- Use absolute imports with `@/` prefix
- Group imports: React, Next.js, third-party, local
- Use named imports for utilities, default for components
- Import types with `import type` syntax

## Code Quality

### Performance

- Use React.memo for expensive components
- Implement proper loading states
- Use Next.js Image component for images
- Optimize bundle size with dynamic imports
- Use proper caching strategies with React Query

### Accessibility

- Use semantic HTML elements
- Include proper ARIA attributes
- Ensure keyboard navigation
- Use Radix UI components for complex interactions
- Test with screen readers

### WCAG 2.1 AA Compliance

#### Perceivable (Guideline 1)

- **1.1 Text Alternatives**: Provide alt text for all images, icons, and non-text content
- **1.2 Time-based Media**: Include captions for videos and transcripts for audio
- **1.3 Adaptable**: Use semantic HTML structure with proper headings (h1-h6)
- **1.4 Distinguishable**:
  - Maintain minimum 4.5:1 contrast ratio for normal text
  - Maintain minimum 3:1 contrast ratio for large text (18pt+ or 14pt+ bold)
  - Don't rely solely on color to convey information
  - Ensure text can be resized up to 200% without loss of functionality

#### Operable (Guideline 2)

- **2.1 Keyboard Accessible**: All functionality must be accessible via keyboard
- **2.2 Enough Time**: Provide sufficient time to read and use content
- **2.3 Seizures and Physical Reactions**: Avoid content that flashes more than 3 times per second
- **2.4 Navigable**:
  - Provide clear navigation structure
  - Use descriptive page titles
  - Implement skip links for main content
  - Ensure logical tab order
  - Provide multiple ways to find pages
- **2.5 Input Modalities**: Support touch, mouse, and keyboard interactions

#### Understandable (Guideline 3)

- **3.1 Readable**: Use clear, simple language and provide definitions for unusual words
- **3.2 Predictable**:
  - Maintain consistent navigation and identification
  - Don't change context on user input without warning
- **3.3 Input Assistance**:
  - Provide clear error messages and suggestions
  - Use proper form labels and fieldset/legend for groups
  - Implement proper validation with helpful error descriptions

#### Robust (Guideline 4)

- **4.1 Compatible**: Ensure compatibility with assistive technologies
- **4.2 Status Messages**: Use appropriate ARIA live regions for dynamic content updates

#### Implementation Requirements

- Use proper ARIA roles, states, and properties
- Implement focus management for modals and dynamic content
- Provide skip links for navigation-heavy pages
- Use proper heading hierarchy (h1 → h2 → h3, etc.)
- Ensure all interactive elements are keyboard accessible
- Test with screen readers (NVDA, JAWS, VoiceOver)
- Validate color contrast with tools like WebAIM Contrast Checker
- Use proper form labels and field associations
- Implement proper error handling with descriptive messages
- Ensure touch targets are at least 44x44px for mobile accessibility

### Semantic HTML Guidelines for JSX

#### Document Structure

- Use `<main>` for the primary content area of each page
- Use `<header>` for introductory content, navigation, and site branding
- Use `<footer>` for footer information, links, and copyright
- Use `<nav>` for navigation menus and links
- Use `<aside>` for complementary content (sidebars, pull quotes)
- Use `<section>` for thematic grouping of content
- Use `<article>` for self-contained, independently distributable content
- Use `<address>` for contact information

#### Text and Content

- Use `<h1>` through `<h6>` for headings with proper hierarchy
- Use `<p>` for paragraphs of text
- Use `<blockquote>` for quoted content
- Use `<cite>` for citations and references
- Use `<code>` for inline code snippets
- Use `<pre>` for code blocks with preserved formatting
- Use `<kbd>` for keyboard input
- Use `<mark>` for highlighted text
- Use `<time>` for dates and times with datetime attribute
- Use `<abbr>` for abbreviations with title attribute

#### Lists and Navigation

- Use `<ul>` for unordered lists
- Use `<ol>` for ordered lists
- Use `<li>` for list items
- Use `<dl>`, `<dt>`, `<dd>` for description lists
- Use `<nav>` with `<ul>` for navigation menus
- Use `<menu>` for toolbar-style navigation

#### Forms and Interactive Elements

- Use `<form>` for form containers
- Use `<fieldset>` to group related form controls
- Use `<legend>` to provide fieldset labels
- Use `<label>` for form control labels with proper `for` attribute
- Use `<input>` with appropriate `type` attributes
- Use `<textarea>` for multi-line text input
- Use `<select>` and `<option>` for dropdown selections
- Use `<button>` for interactive buttons
- Use `<datalist>` for input suggestions

#### Media and Embedding

- Use `<img>` with meaningful `alt` attributes
- Use `<picture>` for responsive images
- Use `<figure>` and `<figcaption>` for images with captions
- Use `<video>` and `<audio>` for media content
- Use `<iframe>` for embedded content with proper titles
- Use `<embed>` or `<object>` for external content

#### Data and Tables

- Use `<table>` for tabular data only
- Use `<thead>`, `<tbody>`, `<tfoot>` for table sections
- Use `<tr>` for table rows
- Use `<th>` for header cells with proper scope
- Use `<td>` for data cells
- Use `<caption>` for table descriptions
- Use `<colgroup>` and `<col>` for column styling

#### JSX-Specific Best Practices

- Use semantic elements instead of generic `<div>` when possible
- Avoid using `<div>` for content that has semantic meaning
- Use React fragments (`<>...</>`) instead of unnecessary wrapper divs
- Apply ARIA attributes to semantic elements when needed
- Use proper event handlers (onClick, onSubmit, onChange)
- Ensure all interactive elements have proper keyboard event handlers
- Use `role` attribute only when necessary to override semantic meaning
- Use `aria-*` attributes to enhance semantic meaning, not replace it

#### Common Anti-Patterns to Avoid

- Don't use `<div>` for navigation (use `<nav>`)
- Don't use `<div>` for main content (use `<main>`)
- Don't use `<div>` for headings (use `<h1>`-`<h6>`)
- Don't use `<div>` for lists (use `<ul>`, `<ol>`, `<dl>`)
- Don't use `<div>` for buttons (use `<button>`)
- Don't use `<div>` for links (use `<a>`)
- Don't use `<div>` for form elements (use proper form elements)
- Don't use `<span>` for block-level content
- Don't use `<p>` for non-paragraph content

### Error Handling

- Use proper error boundaries
- Implement loading and error states
- Use TypeScript for compile-time error prevention
- Handle async operations gracefully

## Development Guidelines

### Git & Version Control

- Use conventional commit messages
- Keep commits focused and atomic
- Use feature branches for new development
- Update dependencies regularly

### Testing

- Write unit tests for utility functions
- Test component behavior with user interactions
- Use proper mocking for external dependencies
- Test accessibility features

### Documentation

- Use JSDoc comments for complex functions
- Document component props with TypeScript interfaces
- Keep README updated with setup instructions
- Document any non-obvious business logic

## Specific Patterns

### Theme Implementation

- Use Next Themes for dark/light mode
- Define CSS custom properties for colors
- Use Tailwind's dark mode utilities
- Ensure proper color contrast ratios

### API Integration

- Use React Query for data fetching
- Implement proper error handling
- Use optimistic updates where appropriate
- Cache data efficiently

### Component Composition

- Use composition over inheritance
- Pass children as props when appropriate
- Use render props for flexible components
- Keep components pure and predictable

## Avoid

- Don't use `any` type in TypeScript
- Don't mix different styling approaches
- Don't create overly complex components
- Don't ignore accessibility requirements
- Don't use deprecated React patterns
- Don't commit console.log statements
- Don't use inline styles unless absolutely necessary

## Prefer

- TypeScript strict mode compliance
- Functional components with hooks
- Server components when possible
- Tailwind utility classes
- Proper error boundaries
- Semantic HTML
- Performance optimization
- Accessibility-first approach
